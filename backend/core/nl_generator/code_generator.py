"""
代码生成器模块 - Code Generator

负责生成Pipeline和Agent的代码
"""

import json
from typing import Dict, List, Any, Optional
from dataclasses import dataclass
from .pipeline_generator import Pipeline, PipelineGenerator, NodeType
from .agent_generator import Agent, AgentGenerator, SkillType


@dataclass
class GeneratedCode:
    """生成的代码"""
    filename: str
    content: str
    language: str = "python"
    description: str = ""


class CodeGenerator:
    """代码生成器"""
    
    def __init__(self):
        self.generated_files = []
    
    def generate_pipeline_code(self, pipeline: Pipeline) -> List[GeneratedCode]:
        """
        生成Pipeline代码
        
        Args:
            pipeline: Pipeline实例
            
        Returns:
            List[GeneratedCode]: 生成的代码列表
        """
        files = []
        
        # 1. 生成主Pipeline类
        main_code = self._generate_pipeline_class(pipeline)
        files.append(GeneratedCode(
            filename=f"{pipeline.name.lower().replace(' ', '_')}_pipeline.py",
            content=main_code,
            language="python",
            description=f"Pipeline: {pipeline.name}"
        ))
        
        # 2. 生成节点定义
        node_code = self._generate_node_definitions(pipeline)
        files.append(GeneratedCode(
            filename=f"{pipeline.name.lower().replace(' ', '_')}_nodes.py",
            content=node_code,
            language="python",
            description=f"Nodes for {pipeline.name}"
        ))
        
        # 3. 生成配置
        config_code = self._generate_pipeline_config(pipeline)
        files.append(GeneratedCode(
            filename=f"{pipeline.name.lower().replace(' ', '_')}_config.py",
            content=config_code,
            language="python",
            description=f"Config for {pipeline.name}"
        ))
        
        # 4. 生成测试代码
        test_code = self._generate_pipeline_test(pipeline)
        files.append(GeneratedCode(
            filename=f"test_{pipeline.name.lower().replace(' ', '_')}_pipeline.py",
            content=test_code,
            language="python",
            description=f"Tests for {pipeline.name}"
        ))
        
        self.generated_files = files
        return files
    
    def generate_agent_code(self, agent: Agent) -> List[GeneratedCode]:
        """
        生成Agent代码
        
        Args:
            agent: Agent实例
            
        Returns:
            List[GeneratedCode]: 生成的代码列表
        """
        files = []
        
        # 1. 生成主Agent类
        main_code = self._generate_agent_class(agent)
        files.append(GeneratedCode(
            filename=f"{agent.name.lower().replace(' ', '_')}_agent.py",
            content=main_code,
            language="python",
            description=f"Agent: {agent.name}"
        ))
        
        # 2. 生成技能实现
        skill_code = self._generate_skill_implementations(agent)
        files.append(GeneratedCode(
            filename=f"{agent.name.lower().replace(' ', '_')}_skills.py",
            content=skill_code,
            language="python",
            description=f"Skills for {agent.name}"
        ))
        
        # 3. 生成记忆配置
        memory_code = self._generate_memory_config(agent)
        files.append(GeneratedCode(
            filename=f"{agent.name.lower().replace(' ', '_')}_memory.py",
            content=memory_code,
            language="python",
            description=f"Memory config for {agent.name}"
        ))
        
        # 4. 生成测试代码
        test_code = self._generate_agent_test(agent)
        files.append(GeneratedCode(
            filename=f"test_{agent.name.lower().replace(' ', '_')}_agent.py",
            content=test_code,
            language="python",
            description=f"Tests for {agent.name}"
        ))
        
        self.generated_files = files
        return files
    
    def _generate_pipeline_class(self, pipeline: Pipeline) -> str:
        """生成Pipeline类"""
        class_name = self._to_camel_case(pipeline.name)
        
        code = f'''"""
{pipeline.name} Pipeline

Generated by NL Generator
"""

from typing import Dict, List, Any, Optional
from datetime import datetime


class {class_name}Pipeline:
    """
    {pipeline.description}
    
    Version: {pipeline.version}
    """
    
    def __init__(self, config: Optional[Dict[str, Any]] = None):
        self.id = "{pipeline.id}"
        self.name = "{pipeline.name}"
        self.version = "{pipeline.version}"
        self.config = config or {{}}
        self.nodes = self._initialize_nodes()
        self.connections = self._initialize_connections()
        
    def _initialize_nodes(self) -> Dict[str, Any]:
        """初始化节点"""
        nodes = {{}}
'''
        
        for node in pipeline.nodes:
            node_class = self._to_camel_case(node.type.value)
            code += f'''        nodes["{node.id}"] = {{
            "name": "{node.name}",
            "type": "{node.type.value}",
            "class": "{node_class}",
            "config": {json.dumps(node.config, ensure_ascii=False)}
        }}
'''
        
        code += '''        return nodes
    
    def _initialize_connections(self) -> List[Dict]:
        """初始化连接"""
        connections = [
'''
        
        for conn in pipeline.connections:
            code += f'''            {{
                "id": "{conn.id}",
                "source": "{conn.source}",
                "target": "{conn.target}",
                "type": "{conn.type.value}"
            }},
'''
        
        code += '''        ]
        return connections
    
    def execute(self, input_data: Any) -> Any:
        """
        执行Pipeline
        
        Args:
            input_data: 输入数据
            
        Returns:
            Any: 处理结果
        """
        current_data = input_data
        
        # 按连接顺序执行
        node_order = self._get_execution_order()
        
        for node_id in node_order:
            node = self.nodes.get(node_id)
            if node:
                current_data = self._execute_node(node_id, current_data)
        
        return current_data
    
    def _execute_node(self, node_id: str, data: Any) -> Any:
        """执行单个节点"""
        node = self.nodes.get(node_id)
        if not node:
            return data
        
        node_class = node.get("class")
        config = node.get("config", {{}})
        
        # 根据节点类型执行不同逻辑
        if node["type"] == "input":
            return self._process_input(data, config)
        elif node["type"] == "output":
            return self._process_output(data, config)
        elif node["type"] == "processor":
            return self._process_processor(data, config)
        elif node["type"] == "llm":
            return self._process_llm(data, config)
        else:
            return data
    
    def _process_input(self, data: Any, config: Dict) -> Any:
        """处理输入节点"""
        return data
    
    def _process_output(self, data: Any, config: Dict) -> Any:
        """处理输出节点"""
        return data
    
    def _process_processor(self, data: Any, config: Dict) -> Any:
        """处理处理器节点"""
        return data
    
    def _process_llm(self, data: Any, config: Dict) -> Any:
        """处理LLM节点"""
        return data
    
    def _get_execution_order(self) -> List[str]:
        """获取执行顺序"""
        # 简化的拓扑排序
        order = []
        visited = set()
        
        for conn in self.connections:
            if conn["source"] not in visited:
                order.append(conn["source"])
                visited.add(conn["source"])
            if conn["target"] not in visited:
                order.append(conn["target"])
                visited.add(conn["target"])
        
        return order


if __name__ == "__main__":
    # 测试
    pipeline = {class_name}Pipeline()
    result = pipeline.execute({{"test": "data"}})
    print(result)
'''.format(class_name=class_name)
        
        return code
    
    def _generate_node_definitions(self, pipeline: Pipeline) -> str:
        """生成节点定义"""
        code = '''"""
节点定义模块

Generated by NL Generator
"""

from abc import ABC, abstractmethod
from typing import Any, Dict


class BaseNode(ABC):
    """节点基类"""
    
    def __init__(self, name: str, config: Dict[str, Any] = None):
        self.name = name
        self.config = config or {}
    
    @abstractmethod
    def process(self, data: Any) -> Any:
        """处理数据"""
        pass


'''
        
        for node in pipeline.nodes:
            class_name = self._to_camel_case(node.name)
            node_type = node.type.value
            
            code += f'''class {class_name}(BaseNode):
    """
    {node.name}节点
    """
    
    def __init__(self, config: Dict[str, Any] = None):
        super().__init__("{node.name}", config)
        self.node_type = "{node_type}"
    
    def process(self, data: Any) -> Any:
        """
        处理数据
        
        Args:
            data: 输入数据
            
        Returns:
            Any: 处理后的数据
        """
        # TODO: 实现{node.name}节点逻辑
        return data


'''
        
        return code
    
    def _generate_pipeline_config(self, pipeline: Pipeline) -> str:
        """生成配置"""
        code = f'''"""
{pipeline.name} 配置

Generated by NL Generator
"""

from typing import Any, Dict


class PipelineConfig:
    """Pipeline配置"""
    
    # Pipeline基本信息
    ID = "{pipeline.id}"
    NAME = "{pipeline.name}"
    VERSION = "{pipeline.version}"
    
    # 节点配置
    NODES = {json.dumps(pipeline.config, ensure_ascii=False, indent=8)}
    
    # 运行配置
    RUN_CONFIG = {{
        "timeout": 300,
        "retry_times": 3,
        "log_level": "INFO"
    }}
    
    @classmethod
    def get_config(cls) -> Dict[str, Any]:
        """获取完整配置"""
        return {{
            "id": cls.ID,
            "name": cls.NAME,
            "version": cls.VERSION,
            "nodes": cls.NODES,
            "run_config": cls.RUN_CONFIG
        }}


if __name__ == "__main__":
    config = PipelineConfig.get_config()
    print(config)
'''
        
        return code
    
    def _generate_pipeline_test(self, pipeline: Pipeline) -> str:
        """生成测试代码"""
        class_name = self._to_camel_case(pipeline.name)
        
        code = f'''"""
{pipeline.name} 测试用例

Generated by NL Generator
"""

import pytest
from {pipeline.name.lower().replace(' ', '_')}_pipeline import {class_name}Pipeline


class Test{class_name}Pipeline:
    """测试 {pipeline.name} Pipeline"""
    
    @pytest.fixture
    def pipeline(self):
        """创建Pipeline实例"""
        config = {{}}
        return {class_name}Pipeline(config)
    
    def test_initialization(self, pipeline):
        """测试初始化"""
        assert pipeline.id == "{pipeline.id}"
        assert pipeline.name == "{pipeline.name}"
        assert len(pipeline.nodes) == {len(pipeline.nodes)}
    
    def test_execute_simple(self, pipeline):
        """测试简单执行"""
        input_data = {{"test": "data"}}
        result = pipeline.execute(input_data)
        assert result is not None
    
    def test_node_count(self, pipeline):
        """测试节点数量"""
        assert len(pipeline.nodes) == {len(pipeline.nodes)}
    
    def test_connection_count(self, pipeline):
        """测试连接数量"""
        assert len(pipeline.connections) == {len(pipeline.connections)}
'''
        
        return code
    
    def _generate_agent_class(self, agent: Agent) -> str:
        """生成Agent类"""
        class_name = self._to_camel_case(agent.name)
        
        code = f'''"""
{agent.name} Agent

Generated by NL Generator
"""

from typing import Any, Dict, List, Optional
from datetime import datetime
import uuid


class {class_name}Agent:
    """
    {agent.description}
    
    Version: {agent.version}
    """
    
    def __init__(self, config: Optional[Dict[str, Any]] = None):
        self.id = "{agent.id}"
        self.name = "{agent.name}"
        self.version = "{agent.version}"
        self.config = config or {{}}
        self.skills = self._initialize_skills()
        self.memory = self._initialize_memory()
        self.personality = self._initialize_personality()
        self.conversation_history = []
    
    def _initialize_skills(self) -> Dict[str, Any]:
        """初始化技能"""
        skills = {{}}
'''
        
        for skill in agent.skills:
            skill_class = self._to_camel_case(skill.name)
            code += f'''        skills["{skill.id}"] = {{
            "name": "{skill.name}",
            "type": "{skill.type.value}",
            "class": "{skill_class}",
            "enabled": {skill.enabled},
            "config": {json.dumps(skill.config, ensure_ascii=False)}
        }}
'''
        
        code += '''        return skills
    
    def _initialize_memory(self) -> Dict[str, Any]:
        """初始化记忆"""
        return {
            "type": "''' + agent.memory.type.value + '''",
            "max_items": ''' + str(agent.memory.max_items) + ''',
            "embedding_model": "''' + agent.memory.embedding_model + '''",
            "store": []
        }
    
    def _initialize_personality(self) -> Dict[str, Any]:
        """初始化人格"""
        return {
            "traits": ''' + json.dumps([t.value for t in agent.personality.traits]) + ''',
            "tone": "''' + agent.personality.tone + '''",
            "style": "''' + agent.personality.style + '''"
        }
    
    def chat(self, message: str) -> str:
        """
        聊天接口
        
        Args:
            message: 用户消息
            
        Returns:
            str: Agent响应
        """
        # 1. 理解输入
        intent = self._understand_intent(message)
        
        # 2. 检索记忆
        relevant_memory = self._retrieve_memory(message)
        
        # 3. 执行技能
        response = self._execute_skill(intent, message, relevant_memory)
        
        # 4. 更新记忆
        self._update_memory(message, response)
        
        return response
    
    def _understand_intent(self, message: str) -> Dict[str, Any]:
        """理解意图"""
        # TODO: 实现意图理解
        return {"intent": "general", "confidence": 0.8}
    
    def _retrieve_memory(self, query: str) -> List[Dict]:
        """检索记忆"""
        # TODO: 实现记忆检索
        return []
    
    def _execute_skill(self, intent: Dict, message: str, 
                       memory: List[Dict]) -> str:
        """执行技能"""
        # TODO: 实现技能执行
        return "I understand your message."
    
    def _update_memory(self, message: str, response: str):
        """更新记忆"""
        entry = {
            "timestamp": datetime.now().isoformat(),
            "user_message": message,
            "agent_response": response
        }
        self.memory["store"].append(entry)
        
        # 限制记忆数量
        max_items = self.memory.get("max_items", 100)
        if len(self.memory["store"]) > max_items:
            self.memory["store"] = self.memory["store"][-max_items:]


if __name__ == "__main__":
    agent = {{class_name}}Agent()
    response = agent.chat("Hello!")
    print(response)
'''
        
        return code
    
    def _generate_skill_implementations(self, agent: Agent) -> str:
        """生成技能实现"""
        code = '''"""
技能实现模块

Generated by NL Generator
"""

from abc import ABC, abstractmethod
from typing import Any, Dict, List


class BaseSkill(ABC):
    """技能基类"""
    
    def __init__(self, name: str, config: Dict[str, Any] = None):
        self.name = name
        self.config = config or {}
    
    @abstractmethod
    def execute(self, context: Dict[str, Any]) -> Any:
        """执行技能"""
        pass


'''
        
        for skill in agent.skills:
            class_name = self._to_camel_case(skill.name)
            skill_type = skill.type.value
            
            code += f'''class {class_name}(BaseSkill):
    """
    {skill.name}技能
    """
    
    def __init__(self, config: Dict[str, Any] = None):
        super().__init__("{skill.name}", config)
        self.skill_type = "{skill_type}"
    
    def execute(self, context: Dict[str, Any]) -> Any:
        """
        执行技能
        
        Args:
            context: 执行上下文
            
        Returns:
            Any: 执行结果
        """
        # TODO: 实现{skill.name}技能
        return {{"status": "success"}}


'''
        
        return code
    
    def _generate_memory_config(self, agent: Agent) -> str:
        """生成记忆配置"""
        code = f'''"""
{agent.name} 记忆配置

Generated by NL Generator
"""

from typing import Any, Dict, List, Optional


class MemoryConfig:
    """记忆配置"""
    
    TYPE = "{agent.memory.type.value}"
    MAX_ITEMS = {agent.memory.max_items}
    TTL_SECONDS = {agent.memory.ttl_seconds if agent.memory.ttl_seconds else "None"}
    EMBEDDING_MODEL = "{agent.memory.embedding_model}"
    
    @classmethod
    def get_config(cls) -> Dict[str, Any]:
        """获取配置"""
        return {{
            "type": cls.TYPE,
            "max_items": cls.MAX_ITEMS,
            "ttl_seconds": cls.TTL_SECONDS,
            "embedding_model": cls.EMBEDDING_MODEL
        }}


class MemoryStore:
    """记忆存储"""
    
    def __init__(self, config: Dict[str, Any] = None):
        self.config = config or MemoryConfig.get_config()
        self.store: List[Dict] = []
    
    def add(self, key: str, value: Any):
        """添加记忆"""
        self.store.append({{"key": key, "value": value}})
    
    def retrieve(self, query: str, top_k: int = 5) -> List[Any]:
        """检索记忆"""
        # TODO: 实现语义检索
        return []
    
    def clear(self):
        """清空记忆"""
        self.store = []


if __name__ == "__main__":
    config = MemoryConfig.get_config()
    print(config)
'''
        
        return code
    
    def _generate_agent_test(self, agent: Agent) -> str:
        """生成测试代码"""
        class_name = self._to_camel_case(agent.name)
        
        code = f'''"""
{agent.name} 测试用例

Generated by NL Generator
"""

import pytest
from {agent.name.lower().replace(' ', '_')}_agent import {class_name}Agent


class Test{class_name}Agent:
    """测试 {agent.name} Agent"""
    
    @pytest.fixture
    def agent(self):
        """创建Agent实例"""
        config = {{}}
        return {class_name}Agent(config)
    
    def test_initialization(self, agent):
        """测试初始化"""
        assert agent.id == "{agent.id}"
        assert agent.name == "{agent.name}"
        assert len(agent.skills) == {len(agent.skills)}
    
    def test_chat(self, agent):
        """测试聊天"""
        response = agent.chat("Hello!")
        assert isinstance(response, str)
        assert len(response) > 0
    
    def test_skill_count(self, agent):
        """测试技能数量"""
        assert len(agent.skills) == {len(agent.skills)}
    
    def test_memory_initialization(self, agent):
        """测试记忆初始化"""
        assert agent.memory is not None
        assert agent.personality is not None
'''
        
        return code
    
    def _to_camel_case(self, text: str) -> str:
        """转换为驼峰命名"""
        words = text.replace('-', ' ').replace('_', ' ').split()
        return ''.join(word.capitalize() for word in words)
    
    def save_files(self, files: List[GeneratedCode], directory: str = ".") -> List[str]:
        """
        保存生成的代码文件
        
        Args:
            files: 文件列表
            directory: 保存目录
            
        Returns:
            List[str]: 保存的文件路径
        """
        import os
        
        saved_paths = []
        
        for file in files:
            path = os.path.join(directory, file.filename)
            
            # 确保目录存在
            os.makedirs(os.path.dirname(path), exist_ok=True)
            
            with open(path, 'w', encoding='utf-8') as f:
                f.write(file.content)
            
            saved_paths.append(path)
        
        return saved_paths
