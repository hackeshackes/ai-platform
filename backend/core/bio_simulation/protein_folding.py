"""
蛋白质折叠模块 - Protein Folding Module
======================================
实现基于AlphaFold的3D蛋白质结构预测
"""

from dataclasses import dataclass, field
from typing import List, Optional, Dict, Tuple, Any
from enum import Enum
import numpy as np


class AminoAcid:
    """氨基酸定义"""
    
    # 标准20种氨基酸
    STANDARD_AA = {
        'A': 'Alanine', 'R': 'Arginine', 'N': 'Asparagine',
        'D': 'Aspartic acid', 'C': 'Cysteine', 'Q': 'Glutamine',
        'E': 'Glutamic acid', 'G': 'Glycine', 'H': 'Histidine',
        'I': 'Isoleucine', 'L': 'Leucine', 'K': 'Lysine',
        'M': 'Methionine', 'F': 'Phenylalanine', 'P': 'Proline',
        'S': 'Serine', 'T': 'Threonine', 'W': 'Tryptophan',
        'Y': 'Tyrosine', 'V': 'Valine'
    }
    
    # 氨基酸物理化学性质
    HYDROPATHY_INDEX = {
        'A': 1.8, 'R': -4.5, 'N': -3.5, 'D': -3.5, 'C': 2.5,
        'Q': -3.5, 'E': -3.5, 'G': -0.4, 'H': -3.2, 'I': 4.5,
        'L': 3.8, 'K': -3.9, 'M': 1.9, 'F': 2.8, 'P': -1.6,
        'S': -0.8, 'T': -0.7, 'W': -0.9, 'Y': -1.3, 'V': 4.2
    }
    
    # 分子量 (Da)
    MOLECULAR_WEIGHT = {
        'A': 89.09, 'R': 174.20, 'N': 132.12, 'D': 133.10, 'C': 121.16,
        'Q': 146.15, 'E': 147.13, 'G': 75.07, 'H': 155.16, 'I': 131.17,
        'L': 131.17, 'K': 146.19, 'M': 149.21, 'F': 165.19, 'P': 115.13,
        'S': 105.09, 'T': 119.12, 'W': 204.23, 'Y': 181.19, 'V': 117.15
    }
    
    @classmethod
    def get_full_name(cls, code: str) -> str:
        """获取氨基酸全名"""
        return cls.STANDARD_AA.get(code.upper(), 'Unknown')
    
    @classmethod
    def get_molecular_weight(cls, sequence: str) -> float:
        """计算蛋白质分子量"""
        weight = 18.015  # 水分子的分子量 (末端)
        for aa in sequence:
            weight += cls.MOLECULAR_WEIGHT.get(aa.upper(), 0)
        return weight


@dataclass
class Residue:
    """氨基酸残基"""
    position: int
    amino_acid: str
    chain_id: str = "A"
    secondary_structure: str = " coil"  # helix, sheet, coil
    solvent_accessibility: float = 0.0  # 0-1
    phi_angle: Optional[float] = None
    psi_angle: Optional[float] = None
    
    @property
    def full_name(self) -> str:
        return AminoAcid.get_full_name(self.amino_acid)
    
    @property
    def molecular_weight(self) -> float:
        return AminoAcid.get_molecular_weight(self.amino_acid)


@dataclass
class Atom:
    """原子"""
    name: str  # CA, C, N, O, etc.
    element: str
    residue_id: int
    chain_id: str = "A"
    position: Tuple[float, float, float] = (0.0, 0.0, 0.0)
    occupancy: float = 1.0
    temperature_factor: float = 0.0
    charge: float = 0.0
    
    def distance_to(self, other: "Atom") -> float:
        """计算到另一个原子的距离"""
        return np.sqrt(
            (self.position[0] - other.position[0]) ** 2 +
            (self.position[1] - other.position[1]) ** 2 +
            (self.position[2] - other.position[2]) ** 2
        )


@dataclass
class PDBAtom:
    """PDB格式原子记录"""
    record_type: str = "ATOM"
    serial_number: int = 0
    name: str = ""
    alt_location: str = ""
    residue_name: str = ""
    chain_id: str = ""
    residue_number: int = 0
    insertion_code: str = ""
    x: float = 0.0
    y: float = 0.0
    z: float = 0.0
    occupancy: float = 0.0
    temperature_factor: float = 0.0
    element: str = ""
    charge: str = ""
    
    def to_pdb_line(self) -> str:
        """转换为PDB格式行"""
        return (
            f"{self.record_type:<6}{self.serial_number:>5} {self.name:<4}"
            f"{self.alt_location:<1}{self.residue_name:<3} {self.chain_id:<1}"
            f"{self.residue_number:>4}{self.insertion_code:<1}   "
            f"{self.x:>8.3f}{self.y:>8.3f}{self.z:>8.3f}"
            f"{self.occupancy:>6.2f}{self.temperature_factor:>6.2f}          "
            f"{self.element:>2}{self.charge:<2}"
        )


@dataclass
class ProteinStructure:
    """蛋白质3D结构"""
    sequence: str
    residues: List[Residue] = field(default_factory=list)
    atoms: List[Atom] = field(default_factory=list)
    pdb_atoms: List[PDBAtom] = field(default_factory=list)
    
    # 元数据
    model_id: str = ""
    method: str = ""
    confidence_score: float = 0.0
    resolution: Optional[float] = None
    
    # 预测信息
    predicted_lddt: Optional[np.ndarray] = None  # 局部距离差异检验
    predicted_plddt: Optional[np.ndarray] = None  # 每残基置信度
    msas: Optional[Dict[str, np.ndarray]] = None  # 多序列比对
    
    # 二级结构
    secondary_structure_string: str = ""
    
    def add_residue(self, residue: Residue):
        """添加残基"""
        self.residues.append(residue)
    
    def add_atom(self, atom: Atom):
        """添加原子"""
        self.atoms.append(atom)
    
    def to_pdb(self) -> str:
        """转换为PDB格式"""
        lines = ["HEADER    Generated by BioSimulation"]
        lines.append("TITLE     Protein Structure Prediction")
        
        for pdb_atom in self.pdb_atoms:
            lines.append(pdb_atom.to_pdb_line())
        
        lines.append("END")
        return "\n".join(lines)
    
    def get_ca_positions(self) -> np.ndarray:
        """获取Cα原子位置"""
        ca_positions = []
        for atom in self.atoms:
            if atom.name == "CA":
                ca_positions.append(atom.position)
        return np.array(ca_positions)
    
    def calculate_rmsd(self, other: "ProteinStructure") -> float:
        """计算与另一个结构的RMSD"""
        pos1 = self.get_ca_positions()
        pos2 = other.get_ca_positions()
        
        if len(pos1) != len(pos2):
            return float('inf')
        
        # Kabsch算法进行最优叠加
        pos1_centered = pos1 - np.mean(pos1, axis=0)
        pos2_centered = pos2 - np.mean(pos2, axis=0)
        
        covariance = np.dot(pos1_centered.T, pos2_centered)
        u, s, vh = np.linalg.svd(covariance)
        
        d = np.sign(np.linalg.det(u @ vh))
        r = np.array([[1, 0, 0], [0, 1, 0], [0, 0, d]])
        
        rotation = u @ r @ vh
        rotated = pos2_centered @ rotation.T
        
        rmsd = np.sqrt(np.mean(np.sum((pos1_centered - rotated) ** 2, axis=1)))
        return float(rmsd)
    
    def get_confidence(self) -> float:
        """获取整体置信度"""
        if self.predicted_plddt is not None and len(self.predicted_plddt) > 0:
            return float(np.mean(self.predicted_plddt))
        return self.confidence_score


class ProteinFolding:
    """
    蛋白质折叠预测器
    
    基于深度学习的3D蛋白质结构预测，参考AlphaFold架构
    """
    
    def __init__(self, config=None):
        """初始化蛋白质折叠器"""
        self.config = config
        self.model = None
        self._initialize_model()
    
    def _initialize_model(self):
        """初始化预测模型"""
        # 模型占位 - 实际实现需要加载预训练权重
        self.model_ready = True
    
    def predict(self, sequence: str, 
                msa: Optional[np.ndarray] = None,
                templates: Optional[List[Dict]] = None) -> ProteinStructure:
        """
        预测蛋白质3D结构
        
        Args:
            sequence: 氨基酸序列
            msa: 多序列比对 (可选)
            templates: 同源模板 (可选)
            
        Returns:
            ProteinStructure: 预测的蛋白质结构
        """
        # 验证序列
        sequence = sequence.upper()
        valid_aa = set(AminoAcid.STANDARD_AA.keys())
        invalid_aa = set(sequence) - valid_aa
        
        if invalid_aa:
            raise ValueError(f"Invalid amino acids in sequence: {invalid_aa}")
        
        if len(sequence) > 2500:
            raise ValueError(f"Sequence too long: {len(sequence)} (max 2500)")
        
        # 创建结构对象
        structure = ProteinStructure(
            sequence=sequence,
            method="AlphaFold-style prediction",
            model_id=self._generate_model_id()
        )
        
        # 生成残基
        for i, aa in enumerate(sequence):
            residue = Residue(
                position=i + 1,
                amino_acid=aa,
                chain_id="A"
            )
            structure.add_residue(residue)
        
        # 生成3D坐标 (简化版本 - 实际需要深度学习模型)
        coordinates = self._generate_coordinates(sequence)
        
        for i, (x, y, z) in enumerate(coordinates):
            # 主链原子
            for atom_name, element, offset in [
                ("N", "N", 0), ("CA", "C", 1), ("C", "C", 2), ("O", "O", 0), ("CB", "C", 3)
            ]:
                if i + offset < len(coordinates):
                    pos = coordinates[i + offset]
                    atom = Atom(
                        name=atom_name,
                        element=element,
                        residue_id=i + 1,
                        position=(pos[0] + np.random.normal(0, 0.1),
                                 pos[1] + np.random.normal(0, 0.1),
                                 pos[2] + np.random.normal(0, 0.1))
                    )
                    structure.add_atom(atom)
        
        # 生成预测置信度
        structure.predicted_plddt = self._generate_confidence(len(sequence))
        structure.confidence_score = float(np.mean(structure.predicted_plddt))
        
        # 生成二级结构预测
        structure.secondary_structure_string = self._predict_secondary_structure(sequence)
        for i, ss in enumerate(structure.secondary_structure_string):
            if i < len(structure.residues):
                structure.residues[i].secondary_structure = ss
        
        # 生成PDB格式
        structure.pdb_atoms = self._generate_pdb_atoms(structure)
        
        return structure
    
    def _generate_model_id(self) -> str:
        """生成模型ID"""
        import hashlib
        import time
        hash_input = f"{time.time()}_{np.random.random()}"
        return hashlib.md5(hash_input.encode()).hexdigest()[:8].upper()
    
    def _generate_coordinates(self, sequence: str) -> np.ndarray:
        """生成蛋白质骨架坐标 (简化螺旋模型)"""
        n_residues = len(sequence)
        coordinates = np.zeros((n_residues, 3))
        
        # 使用螺旋参数生成初始坐标
        for i in range(n_residues):
            angle = 100 * np.pi / 180  # 螺旋角
            rise = 1.5  # 每个残基的上升
        
        # 简化：使用随机游走 + 链约束
        coordinates[0] = [0, 0, 0]
        
        for i in range(1, n_residues):
            # 添加随机偏移
            step = np.random.normal(3.8, 0.5)  # Cα-Cα距离
            direction = np.random.randn(3)
            direction = direction / np.linalg.norm(direction)
            
            coordinates[i] = coordinates[i-1] + direction * step
        
        return coordinates
    
    def _generate_confidence(self, length: int) -> np.ndarray:
        """生成预测置信度分数"""
        # 模拟置信度 (中心区域通常更可信)
        confidence = np.random.uniform(70, 95, length)
        
        # N端和C端通常置信度较低
        confidence[:5] *= np.linspace(0.8, 1.0, 5)
        confidence[-5:] *= np.linspace(1.0, 0.8, 5)
        
        return np.clip(confidence, 0, 100)
    
    def _predict_secondary_structure(self, sequence: str) -> str:
        """预测二级结构 (简化版)"""
        # 使用Chou-Fasman方法的简化版本
        p_aa = {
            'E': {'H': 1.51, 'B': 0.13, 'C': 0.56},
            'A': {'H': 1.42, 'B': 0.83, 'C': 0.75},
            'L': {'H': 1.21, 'B': 1.30, 'C': 0.59},
            'M': {'H': 1.45, 'B': 1.05, 'C': 0.60},
            'F': {'H': 1.13, 'B': 1.13, 'C': 0.60},
            'W': {'H': 1.08, 'B': 1.37, 'C': 0.55},
            'K': {'H': 1.16, 'B': 0.74, 'C': 1.01},
            'I': {'H': 1.08, 'B': 1.60, 'C': 0.47},
            'V': {'H': 1.06, 'B': 1.70, 'C': 0.50},
            'R': {'H': 0.98, 'B': 0.93, 'C': 0.95},
            'D': {'H': 1.01, 'B': 0.54, 'C': 1.46},
            'T': {'H': 0.83, 'B': 0.96, 'C': 0.96},
            'S': {'H': 0.77, 'B': 0.75, 'C': 1.43},
            'C': {'H': 0.70, 'B': 1.19, 'C': 1.00},
            'G': {'H': 0.57, 'B': 0.75, 'C': 1.56},
            'N': {'H': 0.67, 'B': 0.89, 'C': 1.56},
            'P': {'H': 0.55, 'B': 0.55, 'C': 1.52},
            'Q': {'H': 1.11, 'B': 1.10, 'C': 0.98},
            'Y': {'H': 0.69, 'B': 1.47, 'C': 0.95},
            'H': {'H': 0.87, 'B': 0.95, 'C': 0.93}
        }
        
        # 简化的二级结构预测
        structure = []
        for aa in sequence:
            props = p_aa.get(aa, {'H': 1.0, 'B': 1.0, 'C': 1.0})
            
            if props['H'] > 1.0:
                structure.append('H')  # α螺旋
            elif props['B'] > 1.3:
                structure.append('E')  # β折叠
            else:
                structure.append('C')  # 无规卷曲
        
        return ''.join(structure)
    
    def _generate_pdb_atoms(self, structure: ProteinStructure) -> List[PDBAtom]:
        """生成PDB格式原子记录"""
        pdb_atoms = []
        serial = 0
        
        for atom in structure.atoms:
            serial += 1
            res_name = AminoAcid.get_full_name(structure.sequence[atom.residue_id - 1])[:3]
            
            pdb_atom = PDBAtom(
                serial_number=serial,
                name=atom.name.ljust(4)[:4],
                residue_name=res_name,
                chain_id=atom.chain_id,
                residue_number=atom.residue_id,
                x=atom.position[0],
                y=atom.position[1],
                z=atom.position[2],
                occupancy=atom.occupancy,
                temperature_factor=atom.temperature_factor,
                element=atom.element.ljust(2)[:2]
            )
            pdb_atoms.append(pdb_atom)
        
        return pdb_atoms
    
    def run_molecular_dynamics(self, structure: ProteinStructure,
                                temperature: float = 300.0,
                                duration: float = 10.0) -> ProteinStructure:
        """
        对预测结构进行分子动力学模拟优化
        
        Args:
            structure: 初始蛋白质结构
            temperature: 模拟温度 (K)
            duration: 模拟时长 (ns)
            
        Returns:
            优化后的蛋白质结构
        """
        # 简化的MD模拟 - 实际需要专门的MD引擎
        optimized = ProteinStructure(
            sequence=structure.sequence,
            method=f"MD refined at {temperature}K",
            model_id=structure.model_id
        )
        
        # 复制原始坐标
        optimized.atoms = structure.atoms.copy()
        optimized.residues = structure.residues.copy()
        optimized.pdb_atoms = structure.pdb_atoms.copy()
        
        # 添加轻微的热运动
        for atom in optimized.atoms:
            noise = np.random.normal(0, 0.05, 3)
            atom.position = (
                atom.position[0] + noise[0],
                atom.position[1] + noise[1],
                atom.position[2] + noise[2]
            )
        
        # 更新PDB记录
        optimized.pdb_atoms = self._generate_pdb_atoms(optimized)
        
        return optimized
    
    def search_conformations(self, structure: ProteinStructure,
                              num_conformations: int = 10) -> List[ProteinStructure]:
        """
        构象空间搜索
        
        Args:
            structure: 参考结构
            num_conformations: 生成构象数量
            
        Returns:
            构象列表
        """
        conformations = []
        
        for i in range(num_conformations):
            # 创建变体构象
            conf = ProteinStructure(
                sequence=structure.sequence,
                method="Conformation sampling",
                model_id=f"{structure.model_id}_conf{i}"
            )
            
            # 复制残基
            conf.residues = structure.residues.copy()
            
            # 生成偏移坐标
            offset = np.random.randn(3) * 2.0
            for j, atom in enumerate(structure.atoms):
                new_atom = Atom(
                    name=atom.name,
                    element=atom.element,
                    residue_id=atom.residue_id,
                    chain_id=atom.chain_id,
                    position=(
                        atom.position[0] + offset[0] + np.random.normal(0, 0.5),
                        atom.position[1] + offset[1] + np.random.normal(0, 0.5),
                        atom.position[2] + offset[2] + np.random.normal(0, 0.5)
                    )
                )
                conf.add_atom(new_atom)
            
            conf.pdb_atoms = self._generate_pdb_atoms(conf)
            conformations.append(conf)
        
        return conformations
